/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  McpServer,
  ResourceMetadata,
  ResourceTemplate,
} from "@modelcontextprotocol/sdk/server/mcp.js";
import { RequestHandlerExtra } from "@modelcontextprotocol/sdk/shared/protocol.js";
import { Variables } from "@modelcontextprotocol/sdk/shared/uriTemplate.js";
import {
  ReadResourceResult,
  ServerNotification,
  ServerRequest,
} from "@modelcontextprotocol/sdk/types.js";
import { SDKCore } from "../core.js";
import { ConsoleLogger } from "./console-logger.js";
import { MCPScope } from "./scopes.js";
import { valueToBase64 } from "./shared.js";

export type ReadResourceCallback = (
  client: SDKCore,
  uri: URL,
  extra: RequestHandlerExtra<ServerRequest, ServerNotification>,
) => ReadResourceResult | Promise<ReadResourceResult>;

export type ResourceDefinition = {
  name: string;
  description?: string;
  metadata?: ResourceMetadata;
  scopes?: MCPScope[];
  resource: string;
  read: ReadResourceCallback;
};

export type ReadResourceTemplateCallback = (
  client: SDKCore,
  uri: URL,
  vars: Variables,
  extra: RequestHandlerExtra<ServerRequest, ServerNotification>,
) => ReadResourceResult | Promise<ReadResourceResult>;

export type ResourceTemplateDefinition = {
  name: string;
  description: string;
  metadata?: ResourceMetadata;
  scopes?: MCPScope[];
  resource: ResourceTemplate;
  read: ReadResourceTemplateCallback;
};

// Optional function to assist with formatting tool results
export async function formatResult(
  response: Response,
  uri: URL,
  init?: { mimeType?: string | undefined },
): Promise<ReadResourceResult> {
  let contents: ReadResourceResult["contents"] = [];
  const mimeType = init?.mimeType ?? response.headers.get("content-type") ?? "";

  if (mimeType.startsWith("image/") || mimeType.startsWith("audio/")) {
    const blob = await valueToBase64(await response.arrayBuffer());
    contents = blob == null ? [] : [{ uri: uri.toString(), blob, mimeType }];
  } else {
    const text = await response.text();
    contents = [{ uri: uri.toString(), mimeType, text }];
  }

  return { contents };
}

export function createRegisterResource(
  logger: ConsoleLogger,
  server: McpServer,
  getSDK: () => SDKCore,
  allowedScopes: Set<MCPScope>,
): (resource: ResourceDefinition) => void {
  return (resource: ResourceDefinition): void => {
    const scopes = resource.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }

    if (
      allowedScopes.size > 0
      && !scopes.every((s: MCPScope) => allowedScopes.has(s))
    ) {
      return;
    }

    const metadata: ResourceMetadata = {
      ...resource.metadata,
      description: resource.description,
    };

    server.resource(
      resource.name,
      resource.resource,
      metadata,
      async (uri, ctx) => resource.read(getSDK(), uri, ctx),
    );

    logger.debug("Registered resource", { name: resource.name });
  };
}

export function createRegisterResourceTemplate(
  logger: ConsoleLogger,
  server: McpServer,
  getSDK: () => SDKCore,
  allowedScopes: Set<MCPScope>,
): (resource: ResourceTemplateDefinition) => void {
  return (resource: ResourceTemplateDefinition): void => {
    const scopes = resource.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }

    if (
      allowedScopes.size > 0
      && !scopes.every((s: MCPScope) => allowedScopes.has(s))
    ) {
      return;
    }

    const metadata: ResourceMetadata = {
      ...resource.metadata,
      description: resource.description,
    };

    server.resource(
      resource.name,
      resource.resource,
      metadata,
      async (uri, vars, ctx) => resource.read(getSDK(), uri, vars, ctx),
    );

    logger.debug("Registered resource template", { name: resource.name });
  };
}
